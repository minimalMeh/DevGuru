//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DevGuru.Resources.ua {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class ua {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal ua() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DevGuru.Resources.ua.ua", typeof(ua).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Абстрактні продукти оголошують інтерфейси продуктів, що пов’язані один з одним за змістом, але виконують різні функції..
        /// </summary>
        internal static string AbstractFactory_Step1 {
            get {
                return ResourceManager.GetString("AbstractFactory_Step1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні продукти — великий набір класів, що належать до різних абстрактних продуктів (крісло/столик), але мають одні й ті самі варіації (Вікторіанський/Модерн)..
        /// </summary>
        internal static string AbstractFactory_Step2 {
            get {
                return ResourceManager.GetString("AbstractFactory_Step2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Абстрактна фабрика оголошує методи створення різних абстрактних продуктів (крісло/столик)..
        /// </summary>
        internal static string AbstractFactory_Step3 {
            get {
                return ResourceManager.GetString("AbstractFactory_Step3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні фабрики кожна належить до своєї варіації продуктів (Вікторіанський/Модерн) і реалізує методи абстрактної фабрики, даючи змогу створювати всі продукти певної варіації..
        /// </summary>
        internal static string AbstractFactory_Step4 {
            get {
                return ResourceManager.GetString("AbstractFactory_Step4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Незважаючи на те, що конкретні фабрики породжують конкретні продукти, сигнатури їхніх методів мусять повертати відповідні абстрактні продукти. Це дозволить клієнтського коду, що використовує фабрику, не прив’язуватися до конкретних класів продуктів. Клієнт зможе працювати з будь-якими варіаціями продуктів через абстрактні інтерфейси..
        /// </summary>
        internal static string AbstractFactory_Step5 {
            get {
                return ResourceManager.GetString("AbstractFactory_Step5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Абстракція містить керуючу логіку. Код абстракції делегує реальну роботу пов’язаному об’єктові реалізації..
        /// </summary>
        internal static string Bridge_Step1 {
            get {
                return ResourceManager.GetString("Bridge_Step1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Реалізація описує загальний інтерфейс для всіх реалізацій. Всі методи, які тут описані, будуть доступні з класу абстракції та його підкласів.
        ///
        ///Інтерфейси абстракції та реалізації можуть або збігатися, або бути абсолютно різними. Проте, зазвичай в реалізації живуть базові операції, на яких будуються складні операції абстракції..
        /// </summary>
        internal static string Bridge_Step2 {
            get {
                return ResourceManager.GetString("Bridge_Step2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні реалізації містять залежний від оточення (інколи платформи) код..
        /// </summary>
        internal static string Bridge_Step3 {
            get {
                return ResourceManager.GetString("Bridge_Step3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Розширені абстракції містять різні варіації керуючої логіки. Як і батьківский клас, працює з реалізаціями тільки через загальний інтерфейс реалізацій..
        /// </summary>
        internal static string Bridge_Step4 {
            get {
                return ResourceManager.GetString("Bridge_Step4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Продукт визначає загальний інтерфейс об’єктів, які може створювати творець та його підкласи..
        /// </summary>
        internal static string FactoryMethod_Step1 {
            get {
                return ResourceManager.GetString("FactoryMethod_Step1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні продукти містять код різних продуктів. Продукти відрізнятимуться реалізацією, але інтерфейс у них буде спільним..
        /// </summary>
        internal static string FactoryMethod_Step2 {
            get {
                return ResourceManager.GetString("FactoryMethod_Step2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Творець оголошує фабричний метод, який має повертати нові об’єкти продуктів. Важливо, щоб тип результату цього методу співпадав із загальним інтерфейсом продуктів.
        ///
        ///Зазвичай, фабричний метод оголошують абстрактним, щоб змусити всі підкласи реалізувати його по-своєму. Однак він може також повертати продукт за замовчуванням.
        ///
        ///Незважаючи на назву, важливо розуміти, що створення продуктів не є єдиною і головною функцією творця. Зазвичай він містить ще й інший корисний код для роботи з продуктом. Аналогія: у [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string FactoryMethod_Step3 {
            get {
                return ResourceManager.GetString("FactoryMethod_Step3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні творці по-своєму реалізують фабричний метод, виробляючи ті чи інші конкретні продукти.
        ///
        ///Фабричний метод не зобов’язаний створювати нові об’єкти увесь час. Його можна переписати так, аби повертати з якогось сховища або кешу вже існуючі об’єкти..
        /// </summary>
        internal static string FactoryMethod_Step4 {
            get {
                return ResourceManager.GetString("FactoryMethod_Step4", resourceCulture);
            }
        }
    }
}
