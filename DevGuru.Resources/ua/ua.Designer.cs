//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DevGuru.Resources.ua {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class ua {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal ua() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DevGuru.Resources.ua.ua", typeof(ua).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Абстрактні продукти оголошують інтерфейси продуктів, що пов’язані один з одним за змістом, але виконують різні функції..
        /// </summary>
        internal static string AbstractFactory_Step1 {
            get {
                return ResourceManager.GetString("AbstractFactory_Step1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні продукти — великий набір класів, що належать до різних абстрактних продуктів (крісло/столик), але мають одні й ті самі варіації (Вікторіанський/Модерн)..
        /// </summary>
        internal static string AbstractFactory_Step2 {
            get {
                return ResourceManager.GetString("AbstractFactory_Step2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Абстрактна фабрика оголошує методи створення різних абстрактних продуктів (крісло/столик)..
        /// </summary>
        internal static string AbstractFactory_Step3 {
            get {
                return ResourceManager.GetString("AbstractFactory_Step3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні фабрики кожна належить до своєї варіації продуктів (Вікторіанський/Модерн) і реалізує методи абстрактної фабрики, даючи змогу створювати всі продукти певної варіації..
        /// </summary>
        internal static string AbstractFactory_Step4 {
            get {
                return ResourceManager.GetString("AbstractFactory_Step4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Незважаючи на те, що конкретні фабрики породжують конкретні продукти, сигнатури їхніх методів мусять повертати відповідні абстрактні продукти. Це дозволить клієнтського коду, що використовує фабрику, не прив’язуватися до конкретних класів продуктів. Клієнт зможе працювати з будь-якими варіаціями продуктів через абстрактні інтерфейси..
        /// </summary>
        internal static string AbstractFactory_Step5 {
            get {
                return ResourceManager.GetString("AbstractFactory_Step5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Абстракція містить керуючу логіку. Код абстракції делегує реальну роботу пов’язаному об’єктові реалізації..
        /// </summary>
        internal static string Bridge_Step1 {
            get {
                return ResourceManager.GetString("Bridge_Step1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Реалізація описує загальний інтерфейс для всіх реалізацій. Всі методи, які тут описані, будуть доступні з класу абстракції та його підкласів.
        ///
        ///Інтерфейси абстракції та реалізації можуть або збігатися, або бути абсолютно різними. Проте, зазвичай в реалізації живуть базові операції, на яких будуються складні операції абстракції..
        /// </summary>
        internal static string Bridge_Step2 {
            get {
                return ResourceManager.GetString("Bridge_Step2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні реалізації містять залежний від оточення (інколи платформи) код..
        /// </summary>
        internal static string Bridge_Step3 {
            get {
                return ResourceManager.GetString("Bridge_Step3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Розширені абстракції містять різні варіації керуючої логіки. Як і батьківский клас, працює з реалізаціями тільки через загальний інтерфейс реалізацій..
        /// </summary>
        internal static string Bridge_Step4 {
            get {
                return ResourceManager.GetString("Bridge_Step4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Обробник визначає спільний для всіх конкретних обробників інтерфейс. Зазвичай достатньо описати один метод обробки запитів, але іноді тут може бути оголошений і метод встановлення наступного обробника..
        /// </summary>
        internal static string ChainOfResponsibility_Step1 {
            get {
                return ResourceManager.GetString("ChainOfResponsibility_Step1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Базовий обробник — опціональний клас, який дає змогу позбутися дублювання одного і того самого коду в усіх конкретних обробниках.
        ///
        ///Зазвичай цей клас має поле для зберігання посилання на наступного обробника у ланцюжку. Клієнт зв’язує обробників у ланцюг, подаючи посилання на наступного обробника через конструктор або сетер поля. Також в цьому класі можна реалізувати базовий метод обробки, який би просто перенаправляв запити наступному обробнику, перевіривши його наявність..
        /// </summary>
        internal static string ChainOfResponsibility_Step2 {
            get {
                return ResourceManager.GetString("ChainOfResponsibility_Step2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні обробники містять код обробки запитів. При отриманні запиту кожен обробник вирішує, чи може він обробити запит, а також чи варто передати його наступному об’єкту.
        ///
        ///У більшості випадків обробники можуть працювати самостійно і бути незмінними, отримавши всі необхідні деталі через параметри конструктора..
        /// </summary>
        internal static string ChainOfResponsibility_Step3 {
            get {
                return ResourceManager.GetString("ChainOfResponsibility_Step3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Клієнт може сформувати ланцюжок лише один раз і використовувати його протягом всього часу роботи програми, так і перебудовувати його динамічно, залежно від логіки програми. Клієнт може відправляти запити будь-якому об’єкту ланцюжка, не обов’язково першому з них..
        /// </summary>
        internal static string ChainOfResponsibility_Step4 {
            get {
                return ResourceManager.GetString("ChainOfResponsibility_Step4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Відправник зберігає посилання на об’єкт команди та звертається до нього, коли потрібно виконати якусь дію. Відправник працює з командами тільки через їхній загальний інтерфейс. Він не знає, яку конкретно команду використовує, оскільки отримує готовий об’єкт команди від клієнта..
        /// </summary>
        internal static string Command_Step1 {
            get {
                return ResourceManager.GetString("Command_Step1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Команда описує інтерфейс, спільний для всіх конкретних команд. Зазвичай тут описується лише один метод запуску команди..
        /// </summary>
        internal static string Command_Step2 {
            get {
                return ResourceManager.GetString("Command_Step2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні команди реалізують різні запити, дотримуючись загального інтерфейсу команд. Як правило, команда не робить всю роботу самостійно, а лише передає виклик одержувачу, яким виступає один з об’єктів бізнес-логіки.
        ///
        ///Параметри, з якими команда звертається до одержувача, необхідно зберігати у вигляді полів. У більшості випадків об’єкти команд можна зробити незмінними, передаючи у них всі необхідні параметри тільки через конструктор..
        /// </summary>
        internal static string Command_Step3 {
            get {
                return ResourceManager.GetString("Command_Step3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Одержувач містить бізнес-логіку програми. У цій ролі може виступати практично будь-який об’єкт. Зазвичай, команди перенаправляють виклики одержувачам, але іноді, щоб спростити програму, ви можете позбутися від одержувачів, «зливши» їхній код у класи команд..
        /// </summary>
        internal static string Command_Step4 {
            get {
                return ResourceManager.GetString("Command_Step4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Клієнт створює об’єкти конкретних команд, передаючи до них усі необхідні параметри, серед яких можуть бути і посилання на об’єкти одержувачів. Після цього клієнт зв’язує об’єкти відправників зі створеними командами..
        /// </summary>
        internal static string Command_Step5 {
            get {
                return ResourceManager.GetString("Command_Step5", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Продукт визначає загальний інтерфейс об’єктів, які може створювати творець та його підкласи..
        /// </summary>
        internal static string FactoryMethod_Step1 {
            get {
                return ResourceManager.GetString("FactoryMethod_Step1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні продукти містять код різних продуктів. Продукти відрізнятимуться реалізацією, але інтерфейс у них буде спільним..
        /// </summary>
        internal static string FactoryMethod_Step2 {
            get {
                return ResourceManager.GetString("FactoryMethod_Step2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Творець оголошує фабричний метод, який має повертати нові об’єкти продуктів. Важливо, щоб тип результату цього методу співпадав із загальним інтерфейсом продуктів.
        ///
        ///Зазвичай, фабричний метод оголошують абстрактним, щоб змусити всі підкласи реалізувати його по-своєму. Однак він може також повертати продукт за замовчуванням.
        ///
        ///Незважаючи на назву, важливо розуміти, що створення продуктів не є єдиною і головною функцією творця. Зазвичай він містить ще й інший корисний код для роботи з продуктом. Аналогія: у [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string FactoryMethod_Step3 {
            get {
                return ResourceManager.GetString("FactoryMethod_Step3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретні творці по-своєму реалізують фабричний метод, виробляючи ті чи інші конкретні продукти.
        ///
        ///Фабричний метод не зобов’язаний створювати нові об’єкти увесь час. Його можна переписати так, аби повертати з якогось сховища або кешу вже існуючі об’єкти..
        /// </summary>
        internal static string FactoryMethod_Step4 {
            get {
                return ResourceManager.GetString("FactoryMethod_Step4", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Компоненти — це різнорідні об’єкти, що містять бізнес-логіку програми. Кожен компонент має посилання на об’єкт посередника, але працює з ним тільки через абстрактний інтерфейс посередників. Завдяки цьому компоненти можна повторно використовувати в інших програмах, зв’язавши їх з посередником іншого типу..
        /// </summary>
        internal static string Mediator_Step1 {
            get {
                return ResourceManager.GetString("Mediator_Step1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Посередник визначає інтерфейс для обміну інформацією з компонентами. Зазвичай достатньо одного методу, щоби повідомляти посередника про події, що відбулися в компонентах. У параметрах цього методу можна передавати деталі події: посилання на компонент, в якому вона відбулася, та будь-які інші дані..
        /// </summary>
        internal static string Mediator_Step2 {
            get {
                return ResourceManager.GetString("Mediator_Step2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Конкретний посередник містить код взаємодії кількох компонентів між собою. Найчастіше цей об’єкт не тільки зберігає посилання на всі свої компоненти, але й сам їх створює, керуючи подальшим життєвим циклом..
        /// </summary>
        internal static string Mediator_Step3 {
            get {
                return ResourceManager.GetString("Mediator_Step3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Компоненти не повинні спілкуватися один з одним безпосередньо. Якщо в компоненті відбувається важлива подія, він повинен повідомити свого посередника, а той сам вирішить, чи стосується подія інших компонентів, і чи треба їх сповістити. При цьому компонент-відправник не знає, хто обробить його запит, а компонент-одержувач не знає, хто його надіслав..
        /// </summary>
        internal static string Mediator_Step4 {
            get {
                return ResourceManager.GetString("Mediator_Step4", resourceCulture);
            }
        }
    }
}
